# Copyright 2019 Copyright (c) 2019 SAP SE or an SAP affiliate company. All rights reserved. This file is licensed under the Apache Software License, v. 2 except as noted otherwise in the LICENSE file.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


utilities:
  <<: (( &inject &temporary(merge || ~) ))

  certs:
    #
    # generate a ssh key with the state library
    # offered fields in the value field:
    #   key and pub
    #
    sshKey: (( |size=2048,update=false|->utilities.state.standard(_.sshKeySpec(size),update) ))

    #
    # generate a self signed CA with the state library
    # offered fields in the value field:
    #   key, pub and cert
    #
    selfSignedCA: (( |cn,update=false|->_.keyCert(_.caSpec(cn),update) ))

    #
    # generate a key and cert signed by the given ca.
    # The ca is given by the state field generated by the 
    # selfSignedCA function.
    # offered fields in the value field:
    #   key, pub and cert
    #
    keyCertForCA: (( |certspec,ca,update=false|->_.keyCert({$caCert=ca.value.cert, $caPrivateKey=ca.value.key} certspec,update) ))

    #
    # generate a certificate state for a given cert spec
    # using the state libraray.
    # It must contain all the required key and cert fields.
    # offered fields in the value field:
    #   key, pub and cert
    #
    keyCert: (( |certspec,update=false|->utilities.state.standard(_.keyCertSpec(certspec),update) ))


    #
    # generate a secret value, if no default is given
    # the length parameter specifies the length of the generated secret.
    #
    secret: (( |default,length,update=false|->utilities.state.valuedata(default,_.templates.secret, update) ))

    #######################
    # helper funcions
    #

    #
    # generate a spec for a ssh key value to be
    # generated by the state library given a bit size
    #
    sshKeySpec: (( |sshspec|->*_.templates.ssh ))

    #
    # generate a spec for a certificate value to be
    # generated by the state library given a certificate spec
    #
    keyCertSpec: (( |certspec|->*_.templates.spec ))

    #
    # generate a certificate spec for a self signed ca
    # using the given common name
    #
    caSpec:      (( |cn|->*_.templates.ca ))


    #######################
    # helper templates
    #
    templates:
      #
      # the value template used by the state library
      # to generate a new ssh key containing
      # private key (key), public key (pub)
      ssh_value:
        <<: (( &template ))
        state:
          key: (( x509genkey(input) ))
          pub: (( trim(x509publickey(key,"ssh"), " \n") ))

      #
      # the state specification required by
      # the state library. It contains the input field
      # and the value template to generate a new value
      # if state has to be changed.
      # This value template is just always the one declared above
      #
      ssh:
        <<: (( &template ))
        input: (( sshspec ))
        value: (( _.templates.ssh_value ))

      #
      # specification for a self signed ca signing
      #
      ca:
        <<: (( &template ))
        commonName: (( cn ))
        isCA: true
        usage:
          - Signature
          - KeyEncipherment
  
      #
      # the value template used by the state library
      # to generate a new cert value containing
      # private key (key), public key (pub) and the
      # certificate (cert).
      # it requires a binding for input containing
      # a spec field with the certificate specification.
      # This specification is enriched with the newly
      # generated private key. This works for both.
      # self signed ca signing (provate key required)
      # or signing with a separate ca, the the required
      # public key is extracted from the given provate key.
      #
      value:
        <<: (( &template ))
        spec:
          <<: (( input.spec ))
          privateKey: (( state.key ))
        state:
          key: (( x509genkey(2048) ))
          pub: (( x509publickey(key) ))
          cert: (( x509cert(spec) ))
      #
      # the state specification required by
      # the state library. It contains the input field
      # and the value template to generate a new value
      # if state has to be changed.
      # This value template is just always the one declared above
      #
      spec:
        <<: (( &template ))
        input:
          spec: (( certspec ))
        value: (( _.templates.value ))

      #
      # as long as spiff does not offer a secret generation
      # a shell exec will be used to generate a new secret value
      #
      secret: (( &template(input // rand("[:alnum:]", length)) ))
