#
# some utility function to maintain cerificates and keys
# based on the state feature
#
# This library supports
# - ssh keys
# - self-signed CAs
# - CA-based certificates
#

utilities:
  <<: (( &inject &temporary(merge || ~) ))

  certs:
    #
    # generate a ssh key with the state library
    # offered fields in the value field:
    #   key and pub
    #
    wireguardKey: (( |update=false,relpath=[]|->utilities.state.data("",_.templates.wireguard_value,update,relpath) ))

    #
    # generate a ssh key with the state library
    # offered fields in the value field:
    #   key and pub
    #
    sshKey: (( |size=2048,update=false,relpath=[]|->utilities.state.standard(_.sshKeySpec(size),update,relpath) ))

    #
    # generate a self signed CA with the state library
    # offered fields in the value field:
    #   key, pub and cert
    #
    selfSignedCA: (( |cn,update=false,relpath=[]|->_.keyCert(_.caSpec(cn),update,relpath) ))

    #
    # generate a key and cert signed by the given ca.
    # The ca is given by the state field generated by the 
    # selfSignedCA function.
    # offered fields in the value field:
    #   key, pub and cert
    #
    keyCertForCA: (( |certspec,ca,update=false,relpath=[]|->_.keyCert({$caCert=ca.value.cert, $caPrivateKey=ca.value.key} certspec,update,relpath) ))

    #
    # generate a certificate state for a given cert spec
    # using the state libraray.
    # It must contain all the required key and cert fields.
    # offered fields in the value field:
    #   key, pub and cert
    #
    keyCert: (( |certspec,update=false,relpath=[]|->utilities.state.standard(_.keyCertSpec(certspec),update, relpath) ))


    #
    # generate a secret value, if no default is given
    # the length parameter specifies the length of the generated secret.
    #
    secret: (( |default,length,update=false,relpath=[]|->utilities.state.valuedata(default,_.templates.secret, update,relpath) ))

    #######################
    # helper funcions
    #

    #
    # generate a spec for a ssh key value to be
    # generated by the state library given a bit size
    #
    sshKeySpec: (( |sshspec|->*_.templates.ssh ))

    #
    # generate a spec for a certificate value to be
    # generated by the state library given a certificate spec
    #
    keyCertSpec: (( |certspec|->*_.templates.spec ))

    #
    # generate a certificate spec for a self signed ca
    # using the given common name
    #
    caSpec:      (( |cn|->*_.templates.ca ))


    #######################
    # helper templates
    #
    templates:
      #
      # the value template used by the state library
      # to generate a new wireguard key containing
      # private key (key), public key (pub)
      wireguard_value:
        <<: (( &template ))
        state:
          key: (( wggenkey() ))
          pub: (( wgpublickey(key) ))


      #
      # the value template used by the state library
      # to generate a new ssh key containing
      # private key (key), public key (pub)
      ssh_value:
        <<: (( &template ))
        state:
          key: (( x509genkey(input) ))
          pub: (( trim(x509publickey(key,"ssh"), " \n") ))

      #
      # the state specification required by
      # the state library. It contains the input field
      # and the value template to generate a new value
      # if state has to be changed.
      # This value template is just always the one declared above
      #
      ssh:
        <<: (( &template ))
        input: (( sshspec ))
        value: (( _.templates.ssh_value ))

      #
      # specification for a self signed ca signing
      #
      ca:
        <<: (( &template ))
        commonName: (( cn ))
        isCA: true
        usage:
          - Signature
          - KeyEncipherment
  
      #
      # the value template used by the state library
      # to generate a new cert value containing
      # private key (key), public key (pub) and the
      # certificate (cert).
      # it requires a binding for input containing
      # a spec field with the certificate specification.
      # This specification is enriched with the newly
      # generated private key. This works for both.
      # self signed ca signing (provate key required)
      # or signing with a separate ca, the the required
      # public key is extracted from the given provate key.
      #
      value:
        <<: (( &template ))
        spec:
          <<: (( input.spec ))
          privateKey: (( state.key ))
        state:
          key: (( x509genkey(2048) ))
          pub: (( x509publickey(key) ))
          cert: (( x509cert(spec) ))
      #
      # the state specification required by
      # the state library. It contains the input field
      # and the value template to generate a new value
      # if state has to be changed.
      # This value template is just always the one declared above
      #
      spec:
        <<: (( &template ))
        input:
          spec: (( certspec ))
        value: (( _.templates.value ))

      #
      # as long as spiff does not offer a secret generation
      # a shell exec will be used to generate a new secret value
      #
      secret: (( &template(input // rand("[:alnum:]", length)) ))
